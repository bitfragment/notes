---
title: Commonplace book
---


Finding uses for computers to justify their expense
---------------------------------------------------

Apropos "efforts to realize all of the tremendous advantages  the electronic computer will bring to our way of life" (3):

> The electronic engineers have created a giant. We have the task of feeding this giant, and making it work hard enough to pay for his expensive upkeep. (3)

Petersen, Richard M. “Automatic Coding at G. E.” Automatic Coding: Proceedings of the Symposium on Automatic Coding, January 24-25, Franklin Institute, Philadelphia. Philadelphia, PA: The Franklin Institute, 1957. 3–10. Print. Journal of the Franklin Institute Monograph 3.


Philosophy interferes with programming
--------------------------------------

> The computers are never large enough or fast enough. Each breakthrough in hardware technology leads to more massive programming enterprises, new organizational principles, and an enrichment of abstract models. Every reader should ask himself periodically “Toward what end, toward what end?" — but do not ask it too often lest you pass up the fun of programming for the constipation of bittersweet philosophy.

Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. Structure and Interpretation of Computer Programs. Second ed. Cambridge, MA; New York: MIT Press ; McGraw-Hill, 1996. Print. xii-xiii


The mandate of symbolic logic: beyond science
---------------------------------------------

> Symbolic logic is an instrument of exact thought, both analytic and constructive; its mission, accordingly, is not only to validate scientific methods, but also to clarify the semantic confusions that beset the popular mind as well as the professional philosopher at the present time. "Semantics" (blessed word!) is in dire need of responsible analysis and skillful handling, and symbolic logic is the most effective preparation I can think of for a frontal attack on the pathetic muddles of modern philosophical thought. It blasts natural misconceptions with every move, not by a process of "debunking," but by purposeful and lucid constructions of ideas. (7)

Langer, Susanne K. Introduction to Symbolic Logic. Third revised edition. New York: Dover Publications, 1967. Print.


Rapid obsolescence in programming
---------------------------------

> Programming is dynamic in nature! Your good program today will be "old-fashioned" tomorrow. (29)

Waite, John. “Editing Generators.” Symposium on Automatic Programming for Digital Computers, Office of Naval Research, Department of the Navy, Washington, D.C., 13-14 May 1954. Ed. U.S. Navy Mathematical Computing Advisory Panel. Washington, D.C.: U.S. Dept. of Commerce, Office of Technical Services, 1954. 22–29. Print.


The search for a universal pseudocode executable by all types of computers
--------------------------------------------------------------------------

> Sending a problem into a computer nowadays is like sending an expedition to Africa to trade with the natives. It has to be complete with the missionaries to translate and possibly convert the natives. If the missionaries speak only French and the native tongue then we must speak French but if the missionaries speak English too then everything is all right. (6)

Wegstein, Joseph H. “Automatic Coding Principles.” Symposium on Advanced Programming Methods for Digital Computers: Washington, D.C., June 28, 29, 1956. Washington, D.C.: Office of Naval Research, Dept. of the Navy, 1956. 3–6. Print.


The "third language" of pseudocode
----------------------------------

> The crux of what has been done in the past has been the introduction of a third language into programming -- the first two being the language of the machine and the language in which the problem is formulated. (The following analogy is illustrated in Fig. 1.) Until very recently programmers have been like an American who can speak German who finds himself with a Frenchman who can speak Russian. In order to communicate with the Frenchman, the American must find a German who can speak Russian. It would be simpler if the American would learn to speak French or the Frenchman English but, of course, the American would rather have the Frenchman learn to speak English than learn French himself. Similarly, programmers would like computers and data-processing machines to understand the language in which their problems are formulated" (57). [See mcgee1957-fig1-p57.]

McGee, Russell C. “Omnicode -- A Common Language Programming System.” Automatic Coding: Proceedings of the Symposium on Automatic Coding, January 24-25, Franklin Institute, Philadelphia. Philadelphia, PA: The Franklin Institute, 1957. 57–70. Print. H. Journal of the Franklin Institute Monograph 3.
