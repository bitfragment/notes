---
title: 'Nofre et al., "When Technology Became Language: The Origins of the Linguistic Conception of Computer Programming, 1950–1960" (2014)'
type: src
---

```bibtex
@article{nofre_when_2014,
	title = {When {Technology} {Became} {Language}: {The} {Origins} of the {Linguistic} {Conception} of {Computer} {Programming}, 1950–1960},
	volume = {55},
	issn = {1097-3729},
	doi = {10.1353/tech.2014.0031},
	language = {en},
	number = {1},
	journal = {Technology and Culture},
	author = {Nofre, David and Priestley, Mark and Alberts, Gerard},
	year = {2014},
	pages = {40--75}
}
```

Higher-level languages and some hardware independence appeared during the second half of the 1950s. This hardware independence made the new "programming languages" available as new objects of knowledge in themselves. This is significant for both the emergence of a software industry and of the discipline of computer science in the 1960s.

When programming came to be imagined as a linguistic activity, this was a "conceptual transformation" that involved a metaphorization of the word "language." In the mid-1940s, cybernetic discourse described computers as agents, and language was imagined as an attribute of intelligence. During the second half of the 1950s, the language metaphor "lost its anthropomorphic connotation and acquired a more abstract meaning, closely related to the formal languages of logic and linguistics" (41). The development of ALGOL and COBOL brought this metaphorization  its "climax" (42).

Early histories of programming languages (Sammet, Bergin and Gibson, Wexelblat, Knuth and Pardo) focused on individual languages and their technical details. Later historiography (Ceruzzi, Ensmenger, Campbell-Kelly) has taken a wider perspective. But all these approaches "take the *linguistic* nature of computer programming for granted" (43). We forget that this metaphorization has a history, which is connected to the search for hardware independence. (Cites several sources on metaphor in computer science that don't mention the language metaphor itself.)

"By the early 1950s, translation had become a central metaphor used to make sense of the activity of programming [...]. In 1954, for example, the glossary of programming terminology produced by the Association for Computing Machinery (ACM) defined a *compiling routine* as one that “translates a program expressed in pseudo-code into machine code.” Similarly, specialists in computer programming started using the phrase *formula translation* to denote attempts to generate machine code automat- ically from standard mathematical notation. Occasional mentions were made of the possibility of translating between different machine languages, or of developing an order code that would be usable on more than one machine. This tendency was perhaps reinforced by contemporary interest in the machine translation of natural languages, an important field of application of early digital computers that was generously funded by the Department of Defense. In 1954, Margaret Harper, a programmer at Remington Rand, asked: “If Russian can be translated into English... why not one computer code into another?” And a year later, in an internal RAND Corporation document, Allen Newell suggested that through the study of machine translation '[w]e might be a lot closer to ‘real’ automatic programming of computers'." (47–48)

"The term *automatic coding* (later also referred to as *autocoding* or *automatic programming*) was variously defined, but was usually taken to refer to the use of the computer itself to take over routine, mechanizable aspects of the programming process, such as the conversion between binary and decimal representations of numbers, the assembly of subroutines taken from a library into complete programs, or the translation of various forms of pseudo-code into machine code." (49)

The interest in universality of academic researchers like Carr was also political: he did not want universities to be overwhelmed by industry (see [[proglang-src-brown_automatic_1954]]). But in the end, it was the emergence of industry customer user groups that "facilitated the transformation of programming into an activity disconnected from the machine, and it was in this context that the idea of common, or universal, languages really caught fire" (55).
