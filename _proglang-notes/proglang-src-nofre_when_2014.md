---
title: 'Nofre et al., "When Technology Became Language: The Origins of the Linguistic Conception of Computer Programming, 1950–1960" (2014)'
type: src
---

```bibtex
@article{nofre_when_2014,
	title = {When {Technology} {Became} {Language}: {The} {Origins} of the {Linguistic} {Conception} of {Computer} {Programming}, 1950–1960},
	volume = {55},
	issn = {1097-3729},
	doi = {10.1353/tech.2014.0031},
	language = {en},
	number = {1},
	journal = {Technology and Culture},
	author = {Nofre, David and Priestley, Mark and Alberts, Gerard},
	year = {2014},
	pages = {40--75}
}
```

## Emergence of "programming language" as English-language phrase and new object of knowledge

Higher-level languages and some hardware independence appeared during the second half of the 1950s. This hardware independence made the new "programming languages" available as new objects of knowledge in themselves. This is significant for both the emergence of a software industry and of the discipline of computer science in the 1960s.

When programming came to be imagined as a linguistic activity, this was a "conceptual transformation" that involved a metaphorization of the word "language." In the mid-1940s, cybernetic discourse described computers as agents, and language was imagined as an attribute of intelligence. During the second half of the 1950s, the language metaphor "lost its anthropomorphic connotation and acquired a more abstract meaning, closely related to the formal languages of logic and linguistics" (41). The development of ALGOL and COBOL brought this metaphorization its "climax" (42).

## Taking the linguistic nature of computer programming for granted

Early histories of programming languages (Sammet, Bergin and Gibson, Wexelblat, Knuth and Pardo) focused on individual languages and their technical details. Later historiography (Ceruzzi, Ensmenger, Campbell-Kelly) has taken a wider perspective. But all these approaches "take the *linguistic* nature of computer programming for granted" (43). We forget that this metaphorization has a history, which is connected to the search for hardware independence. (Cites several sources on metaphor in computer science that don't mention the language metaphor itself.)

"Matthias Dörries has convincingly argued that scientists consistently push metaphors to the limit, exploring their potential both as a means of thinking and as explanatory tools. This was also the case for the language metaphor in computer programming" (65).

## Translation as a central metaphor

"By the early 1950s, translation had become a central metaphor used to make sense of the activity of programming [...]. In 1954, for example, the glossary of programming terminology produced by the Association for Computing Machinery (ACM) defined a *compiling routine* as one that “translates a program expressed in pseudo-code into machine code.” Similarly, specialists in computer programming started using the phrase *formula translation* to denote attempts to generate machine code automatically from standard mathematical notation. Occasional mentions were made of the possibility of translating between different machine languages, or of developing an order code that would be usable on more than one machine. This tendency was perhaps reinforced by contemporary interest in the machine translation of natural languages, an important field of application of early digital computers that was generously funded by the Department of Defense. In 1954, Margaret Harper, a programmer at Remington Rand, asked: “If Russian can be translated into English... why not one computer code into another?” And a year later, in an internal RAND Corporation document, Allen Newell suggested that through the study of machine translation '[w]e might be a lot closer to ‘real’ automatic programming of computers'." (47–48)

## Automatic coding

"The term *automatic coding* (later also referred to as *autocoding* or *automatic programming*) was variously defined, but was usually taken to refer to the use of the computer itself to take over routine, mechanizable aspects of the programming process, such as the conversion between binary and decimal representations of numbers, the assembly of subroutines taken from a library into complete programs, or the translation of various forms of pseudo-code into machine code." (49)

## The politics of universality

The interest in universality of academic researchers like Carr was also political: he did not want universities to be overwhelmed by industry (see [[proglang-src-brown_automatic_1954]]).

## User groups and UNCOL

In the end, it was the emergence of industry customer user groups that "facilitated the transformation of programming into an activity disconnected from the machine, and it was in this context that the idea of common, or universal, languages really caught fire" (55).

UNCOL (Universal Computer Oriented Language) was imagined as a machine-like intermediate language, rather than a universal "problem-oriented" (higher-level) language. It would translate multiple "problem-oriented" languages into machine code. UNCOL failed and was shut down in 1962. "In today’s technical understanding, it may seem that problem-oriented languages --- in effect, high-level programming languages --- were, in fact, the solution to the portability problem; however, the overall situation at this time was rather confusing. The understanding of programming as a process of human–machine communication was starting to falter, and the notion of language was proving to be fruitful in the development of a machine-independent approach to computer programming. But the move to a machine-independent notion of language was not immediate: programming languages were still thought of as parts of programming systems tied to specific machines" (61).

## IAL - ALGOL

The International Algebraic Language (IAL) formulated at 1958 joint meetings of the ACM Committee on Languages with a West German and Swiss academic computing consortium was imagined as an "algorithmic language," more a scientific notation than a computer code. IAL was specified as "mechanically translatable into machine programs," but no specification of I/O or any other machine-specific functionality was described.

"IAL aimed at multiple levels of universality. Aspiring to be an international and universal human language, analogous to that of mathematics, it combined this goal with the apparently conflicting ambition to be usable on a wide range of computing equipment by reifying the metaphor of 'computer code as language' into the definition of an abstract structure that could be concretely manifested in as many different ways as necessary" (64).

After the report derived from these meetings was published, work was begun by several groups on IAL translators. Along the way, IAL was renamed ALGOL (ALGOrithmic Language). "Ironically," ALGOL implementations turned out to be localized and installation-specific in some cases. Another meeting was held in 1960 to write a specification for ALGOL 60. ALGOL 60 "was defined completely formally, using a notation presented by Backus in 1959" (65).

## Notes on further work to be done

"More work needs to be done in detailing how programming languages were consolidated by basing them on the existing notion of a formal language developed by logicians in the 1930s and appropriated by linguists during the postwar years. In particular, machine-translation projects deserve further attention as spaces of interaction for the communities of linguists, logicians, and programming specialists" (66).
