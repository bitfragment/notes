---
title: Pflüger, "Language in Computing" (2002)
type: src
---

```bibtex
@incollection{pfluger_language_2002,
	address = {Stanford, CA},
	series = {Writing {Science}},
	title = {Language in {Computing}},
	booktitle = {Experimenting in {Tongues}: {Studies} in {Science} and {Language}},
	publisher = {Stanford University Press},
	author = {Pflüger, Jörg},
	editor = {Dörries, Matthias},
	year = {2002},
	pages = {125--164}
}
```

## Does computer science concern language?

It is correct, but *meaninglessly* correct, to say that since computer science concerns formal languages exclusively, that CS involves only mathematics "and has nothing to do with language. Such a statement is similar to saying that everything that can be programmed, can be programmed on a Turing machine. Although both these statements are correct, they have little significance" (125). Why is this the case? Because formal languages are, quite straightforwardly, social constructions. (Also, different programming languages have different expressive dimensions, which is a characteristic "that cannot be grasped in formal terms.") (125)

## What is at stake in understanding CS as concerning language?

"As computer technology deals not only theoretically with formal concepts but also reconstructs reality with its models, there exists a reciprocal effect between mechanization and language. Analogies thus work both ways. The artifacts of computer science affect, in turn, the realm of language, where the mind is at home, and they organize social reality in analogy with reductionistic models of language. One effect of computerization is that many activities are (re)structured in such a way that they seem to be organized by a 'grammar of action' within a framework of formal languages" (130).

## The language analogy in CS

Dealing sensibly with the "language analogy in computer science" requires us to distinguish between the artificial languages of CS and human natural languages, on the other (125-126).

### Historical change in the language analogy

"The language analogy has played different parts in the short but eventful history of computer science. These roles depended, perhaps more strongly than in most other scientific fields, on currently dominant understandings of the functioning of (natural) language" (129). The development of programming techniques has taken place in historical phases that parallel the changing views of language in linguistics and semiotics outlined by Roland Barthes in "The Imagination of Sign": a pre-structuralist taking of the relationship between sign and signified as given yields to a structuralist focus on paradigmatic and systematic relationships between signifiers, which in turns yields to a post-structuralist focus on the syntagmatic process of producing signifiers. (129)

A second, different way to describe the development of software development paradigms during the lifetime of computer science is to say that they have moved from early *syntactic* approaches to *semantic* approaches (structured programming) to *pragmatic* approaches (object-oriented programming) (131).

### History of the language analogy

#### 1940s: latency

Initially, when all code was written for specific machine installations, "aspects of understanding and communication played no significant role. The primary task was to give the computer instructions, which were initially called 'orders.' During this period, programming was not thought of in terms of language in any emphatic sense. The usual term for a programming language was at first a 'coding scheme,' then with the arrival of higher-level programming languages an 'automatic coding scheme.' Of course, the expression 'language' was common from the very beginning as well. However, it meant nothing different from the term *language* in mathematics. For example, Alan Turing used it in this way in a lecture to the London Mathematical Society in 1947" ["Lecture to the London Mathematical Society on 20 February 1947"] (134).

#### 1950s–1960s: growth

"In the 1950s, computer scientists increasingly aimed at making programming more independent from concrete machines and developed artificial languages for more abstract machine models which were sometimes called 'pseudo-codes.' As the problems to be programmed grew much more complex, the focus of attention shifted from coding to the process of formulating and solving these problems. So-called problem-oriented programming languages appeared; the first one was FORTRAN in 1957. Probably, the phrase 'programming language' came into use with problem-oriented programming languages, because they conveyed more the feeling of dealing with a real language. The intention behind them was to support the formulation of algorithms down to the details on a more conceptual level" (134).

By the end of the 1950s "it was commonplace to talk about conversation with the computer," and by the 1960s "[e]xpressions like 'conversational programming,' 'conversational computers,' and 'conversational languages' were in general use" (146).

#### 1970s: eclipse

"At the end of the 1960s, however, the analogy with language lost its prominent place in favor of a spirit of construction, structure, and action. The abandonment of the 'linguistic turn' showed in many areas of computer science. One of the pioneers of computer science, Maurice Wilkes, noticed in his Turing Lecture of 1967 that 'people have now begun to realize that not all problems are linguistic in character, and that it is high time we paid more attention to the way in which data are stored in the computer, that is, to data structures'" (146).

In the 1970s, the "building paradigm" of structured programming conceived the role of a programming language as one of "oversight during the construction of a programming system. Under the paradigm of building programs the relevance of programming language as a coding scheme diminished compared to its role in supporting the specification and design of an executable system" (147).

#### 1980s: revival

The language analogy was revived, however, with the appearance of the GUI and the spread of the communicative messaging and interface (API) paradigms of object-oriented programming, the development culture of which imagined "growing" software, rather than building it (150).
